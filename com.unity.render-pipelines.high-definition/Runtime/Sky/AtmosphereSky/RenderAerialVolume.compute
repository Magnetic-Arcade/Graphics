#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/AtmosphereSky/AtmosphereSkyComputeCommon.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Sky/SkyUtils.hlsl"

////////////////////////////////////////////////////////////
// Camera aerial perspective volume LUT
////////////////////////////////////////////////////////////
#pragma kernel RenderCameraAerialPerspectiveVolumeCS THREADGROUP_SIZE=8
#pragma multi_compile _ MULTISCATTERING_APPROX_ENABLED
#pragma multi_compile _ SECOND_ATMOSPHERE_LIGHT_ENABLED
#pragma enable_d3d11_debug_symbols

RWTexture3D<float4> CameraAerialPerspectiveVolumeUAV;
float AerialPerspectiveStartDepthKm;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, THREADGROUP_SIZE)]
void RenderCameraAerialPerspectiveVolumeCS(uint3 ThreadId : SV_DispatchThreadID)
{
	float2 PixPos = float2(ThreadId.xy) + 0.5f;
	float2 UV = PixPos  * _CameraAerialPerspectiveVolumeSizeAndInvSize.zw;

	float4 SVPos = float4(UV*_ScreenSize.xy, 0.0f, 1.0f);// SV_POS as if resolution was the one from the scene view.
	float3 WorldDir = GetScreenWorldDir(SVPos);
    const float3 V = GetSkyViewDirWS(SVPos.xy);
	float3 CamPos = GetCameraPlanetPos();

	float Slice = ((float(ThreadId.z) + 0.5f) * _AtmosphereCameraAerialPerspectiveVolumeDepthResolutionInv); // +0.5 to always have a distance to integrate over
	Slice *= Slice;	// squared distribution
	Slice *= _AtmosphereCameraAerialPerspectiveVolumeDepthResolution;

	float3 RayStartWorldPos = CamPos + AerialPerspectiveStartDepthKm * -V; // Offset according to start depth
	float ViewHeight;


	// Compute position from froxel information
	float tMax = Slice * _AtmosphereCameraAerialPerspectiveVolumeDepthSliceLengthKm;
	float3 VoxelWorldPos = RayStartWorldPos + tMax * WorldDir;
	float VoxelHeight = length(VoxelWorldPos);

	// Check if the voxel is under the horizon.
	const float UnderGround = VoxelHeight < _BottomRadiusKm;

	// Check if the voxel is beind the planet (to next check for below the horizon case)
	float3 CameraToVoxel = VoxelWorldPos - CamPos;
	float CameraToVoxelLen = length(CameraToVoxel);
	float3 CameraToVoxelDir = CameraToVoxel / CameraToVoxelLen;
	float PlanetNearT = RaySphereIntersectNearest(CamPos, CameraToVoxelDir, float3(0, 0, 0), _BottomRadiusKm);
	bool BelowHorizon = PlanetNearT > 0.0f && CameraToVoxelLen > PlanetNearT;

	if (BelowHorizon || UnderGround)
	{
		CamPos += normalize(CamPos) * 0.02f;	// TODO: investigate why we need this workaround. Without it, we get some bad color and flickering on the ground only (floating point issue with sphere intersection code?).

		float3 VoxelWorldPosNorm = normalize(VoxelWorldPos);
		float3 CamProjOnGround = normalize(CamPos) * _BottomRadiusKm;
		float3 VoxProjOnGround = VoxelWorldPosNorm * _BottomRadiusKm;
		float3 VoxelGroundToRayStart = CamPos - VoxProjOnGround;
		if (BelowHorizon && dot(normalize(VoxelGroundToRayStart), VoxelWorldPosNorm) < 0.0001f)
		{
			// We are behing the sphere and the psehre normal is pointing away from V: we are below the horizon.
			float3 MiddlePoint = 0.5f * (CamProjOnGround + VoxProjOnGround);
			float MiddlePointHeight = length(MiddlePoint);

			// Compute the new position to evaluate and store the value in the voxel.
			// the position is the oposite side of the horizon point from the view point,
			// The offset of 1.001f is needed to get matching colors and for the ray to not hit the earth again later due to floating point accuracy
			float3 MiddlePointOnGround = normalize(MiddlePoint) * _BottomRadiusKm;// *1.001f;
			VoxelWorldPos = CamPos + 2.0f * (MiddlePointOnGround - CamPos);

			//CameraAerialPerspectiveVolumeUAV[ThreadId] = float4(1, 0, 0, 0);
			//return; // debug
		}
		else if (UnderGround)
		{
			//No obstruction from the planet, so use the point on the ground
			VoxelWorldPos = normalize(VoxelWorldPos) * (_BottomRadiusKm);
			//VoxelWorldPos = CamPos + CameraToVoxelDir * PlanetNearT;		// better match but gives visual artefact as visible voxels on a simple plane at altitude 0

			//CameraAerialPerspectiveVolumeUAV[ThreadId] = float4(0, 1, 0, 0);
			//return; // debug
		}

		WorldDir = normalize(VoxelWorldPos - CamPos);
		RayStartWorldPos = CamPos + AerialPerspectiveStartDepthKm * WorldDir; // Offset according to start depth
		tMax = length(VoxelWorldPos - RayStartWorldPos);
	}
	float tMaxMax = tMax;

	// Move ray marching start up to top atmosphere.
	ViewHeight = length(RayStartWorldPos);
	if (ViewHeight >= _TopRadiusKm)
	{
		float3 prevWorlPos = RayStartWorldPos;
		if (!MoveToTopAtmosphere(RayStartWorldPos, WorldDir, _TopRadiusKm))
		{
			// Ray is not intersecting the atmosphere
			CameraAerialPerspectiveVolumeUAV[ThreadId] = float4(0.0f, 0.0f, 0.0f, 1.0f);
			return;
		}
		float LengthToAtmosphere = length(prevWorlPos - RayStartWorldPos);
		if (tMaxMax < LengthToAtmosphere)
		{
			// tMaxMax for this voxel is not within the planet atmosphere
			CameraAerialPerspectiveVolumeUAV[ThreadId] = float4(0.0f, 0.0f, 0.0f, 1.0f);
			return;
		}
		// Now world position has been moved to the atmosphere boundary: we need to reduce tMaxMax accordingly.
		tMaxMax = max(0.0, tMaxMax - LengthToAtmosphere);
	}


	SamplingSetup Sampling;
	{
		Sampling.VariableSampleCount = false;
		Sampling.SampleCountIni = max(1.0f, (float(ThreadId.z) + 1.0f) * _CameraAerialPerspectiveSampleCountPerSlice);
	}
	const bool Ground = false;
	const float DeviceZ = UNITY_RAW_FAR_CLIP_VALUE;
	const bool MieRayPhase = true;
	const float AerialPespectiveViewDistanceScale = _AerialPespectiveViewDistanceScale;
	SingleScatteringResult ss = IntegrateSingleScatteredLuminance(
		float4(PixPos, 0.0f, 1.0f), RayStartWorldPos, WorldDir,
		Ground, Sampling, DeviceZ, MieRayPhase,
		_AtmosphereLightDirection[0].xyz, _AtmosphereLightDirection[1].xyz, _AtmosphereLightColor[0].rgb, _AtmosphereLightColor[1].rgb,
		AerialPespectiveViewDistanceScale,
		tMaxMax);

	const float Transmittance = dot(ss.Transmittance, float3(1.0f / 3.0f, 1.0f / 3.0f, 1.0f / 3.0f));
	CameraAerialPerspectiveVolumeUAV[ThreadId] = float4(ss.L, Transmittance);
}
